# 复制
复制数据出于各种原因
* 使得数据与用户在地理上接近（从而减少延迟）
* 即使系统的一部分出现故障，系统也能继续工作（从而提高可用性）
* 伸缩可以接受读请求的机器数量（从而提高读取吞吐量）

复制的困难之处在于处理复制数据的 变更(change). 以下是三种流行的变更复制算法:
1. single leader
2. multi leader
3. leaderless
## Single Leader 主从
主库写 从库读
* 同步: 等从库响应
* 异步: 不等从库响应

实际操作中, 当数据库启用同步复制, 是让一个从库同步其他从库异步, also called semi-synchronous

通常情况主从复制都配置为完全异步
* Pros:
    * 即使所有从库落后 主库还可以继续处理写入
* Cons
    * 如果主库失效且不可恢复会有数据丢失

### 增加副本数量和替换失败节点
可以锁定数据库但是违背高可用

如此, 使用快照(快照实际氛围两种:镜像快照和增量快照)复制到从库节点并拉取快照之后的所有数据变更

### 节点宕机
#### 从库失效
从库可以从日志中知道，在发生故障之前处理的最后一个事务，并请求在从库断开期间发生的所有数据变更。
#### 主库失效
主库失效需要将一个从库提升为新的主库并重新配置客户端，以便将客户端的写发送给新的主库，其他从库需要开始拉取新主库的数据变更。这个过程叫 failover

可手动恢复可自动恢复, 自动恢复包含以下步骤:
1. 心跳30s没响应超时算挂了
2. 共识选举一个新的主库
3. 重新配置系统启用新的主库

### 复制日志的实现
1. 基于语句(raw sql)的复制 - 非确定性函数如 NOW(), RAND(), 自增列都会造成副作用
2. WAL -  包含哪些磁盘块中的哪些字节发生了更改。与存储引擎耦合过于紧密。
3. 逻辑日志复制(基于行) 修改多行的事务会生成多条这样的日志记录，后面跟着一条指明事务已经提交的记录
    * 插入的行 - 日志包含所有值
    * 删除的行 - 日志包含足够的信息来唯一标识被删除的行， 通常是主键
    * 更新的行 - 日志包含足够的信息来唯一标识被更新的行， 记忆所有列的新值
4. 基于触发器的复制 - 触发器写函数操作数据更改

## 复制延迟问题
就是一个库复制到另一个库的延迟会造成从从库读取时看到果实的信息。这种不一致性时暂时的, 过一会从库会追上主库并于主库保持一致。这种效应被称为 最终一致性。

三个复制延迟时可能发生的问题实力, 并简述解决问题的一些方法:
1. 读己之写 read-after-write 
    * 一些只能由用户本人做写入的操作总是从主库读取数据 - 例如 用户个人资料, 总是从主库读
    * 可以跟踪上次更新的时间，在上次更新后的一分钟内，从主库读。还可以监控从库的复制延迟，防止向任何滞后主库超过一分钟的从库发出查询。
    * 客户端可以记住最近一次写入的时间戳, 系统需要确保从库在处理该用户的读取请求时, 该时间戳前的变更都已经传播到了本从库中。如果当前从库不够新，则可以从另一个从库读取，或者等待从库追赶上来
    * 如果你的副本分布在多个数据中心（为了在地理上接近用户或者出于可用性目的），还会有额外的复杂性。任何需要由主库提供服务的请求都必须路由到包含该主库的数据中心。
    * app上更新浏览器读会使记住用户上次更新时间戳的方法变得更加困难, 需要对元数据进行中心化的存储。
    * 
2. Monotonic read 单调读
    * 用户做了写操作, 从从库3读到 X 的值为是新值, 再读从从库得到了旧值, 发生了时光回溯. 单调读确保用户总是从同一个副本读取. 可以基于用户id做hash选择从库
3. 一致性前缀读 consistent prefix reads
    * 写入顺序A,B读得时候变成B,A. 为了防止这种异常, 需要另一种类型的保证就是一致性前缀读. partitioned DB中的一个特殊问题. 许多分布式数据库中，不同的分区独立运行，因此不存在 全局的写入顺序. 一种解决方案是，确保任何因果相关的写入都写入相同的分区，但在一些应用中可能无法高效地完成这种操作。还有一些显式跟踪因果依赖关系的算法，我们将在 ““此前发生” 的关系和并发” 一节中回到这个话题。

## 多主
在这种情况下，每个主库同时是其他主库的从库。

在单个数据中心内部使用多个主库的配置没有太大意义，因为其导致的复杂性已经超过了能带来的好处。但在一些情况下，这种配置也是合理的 
1. 运维多个数据中心 
    * 性能 - 单主的每个写入都要经过互联网进入主库所在的 db center 增加了写入延迟
    * 容忍数据中心停机 - 单主配置, 主库所在的db center故障了, 故障切换必须使另一个db center的从库称为主库. 多主配置 一个db center 挂了其他db center继续跑
    * 容忍网络问题 - 单主配置对数据中心之间的连接问题非常敏感，因为通过这个连接进行的写操作是同步的。
2. 离线之后仍继续工作 - 例如手机, 笔记本 和其他设备上的日历应用. 
3. 协同编辑 - 多人同时编辑文档。我们通常不会将协作式编辑视为数据库复制问题，但它与前面提到的离线编辑用例有许多相似之处。当一个用户编辑文档时，所做的更改将立即应用到其本地副本（Web 浏览器或客户端应用程序中的文档状态），并异步复制到服务器和编辑同一文档的任何其他用户。

### 处理写冲突
多主复制 - 用户1将Wiki标题A改为B, 用户2将标题从A改为C. 写入冲突
1. 同步冲突检测与异步冲突检测 (这个策略没什么卵用)
    * 原则上，可以使冲突检测同步 - 即等待写入被复制到所有副本，然后再告诉用户写入成功。但是，通过这样做，你将失去多主复制的主要优点：允许每个副本独立地接受写入。 
    * 异步冲突检测 - 两个写入都是成功的，在稍后的某个时间点才能异步地检测到冲突。那时再来要求用户解决冲突可能为时已晚。
2. 避免冲突 - 处理冲突的最简单的策略就是避免它们：如果应用程序可以确保特定记录的所有写入都通过同一个主库，那么冲突就不会发生。但是从另一个角度看它就是单主了。而且当db center出现故障 或者 用户迁移到另一个更接近其他数据中心的位置，冲突避免将失效。
3. 冲突合并 
    * LWW - 数据会丢失
    * 每个replica 有一个唯一的ID ID编号高的写入油更高的优先级 - 数据会丢失
    * 保留所有信息，并编写解决冲突的应用程序代码
    * 以某种方式将这些值合并在一起 - 例如，按字母顺序排序，然后连接它们（合并的标题可能类似于 “B/C”）
4. 自定义冲突解决逻辑 - 解决冲突的最合适的方法可能取决于应用程序，大多数多主复制工具允许使用应用程序代码编写冲突解决逻辑
    * 写时执行 - 只要数据库系统检测到复制更改日志中存在冲突，就会调用冲突处理程序
    * 读时执行 -  当检测到冲突时，所有冲突写入被存储。下一次读取数据时，会将这些多个版本的数据返回给应用程序。应用程序可以提示用户或自动解决冲突，并将结果写回数据库

## 无主
在一些无主复制的实现中，客户端直接将写入发送到几个副本中，而另一些情况下，由一个 协调者（coordinator） 节点代表客户端进行写入。 Dynamo并不使用特定的"协调者"模式，而是采用去中心化的分布式设计。

当不可用的节点重新联机，客户端开始读取它，客户会从响应中拿到 stale value。所以请求不仅仅被发送到一个副本，从不同的节点获得不同的响应，版本号将被用于确定哪个值是更新的。

### 读修复和反熵
Dynamo风格DB在不可用的节点重新联机后经常通过以下两种机制完成追赶:
1. 读修复 - 当客户端并行读取多个节点时，它可以检测到任何陈旧的响应。并将新值写回到该副本。这种方法适用于读频繁的值。
2. 反熵过程(anti-entropy process) - 一些数据存储具有后台进程，该进程不断查找副本之间的数据差异，并将任何缺少的数据从一个副本复制到另一个副本。 与基于领导者的复制中的复制日志不同，此反熵过程不会以任何特定的顺序复制写入，并且在复制数据之前可能会有显著的延迟。

### Quorum
w+r>n
n: number of replicas w: write success is determined w responses r: each query need read r replicas.
* n=3, w=r=2, 可以容忍一个节点不工作(因为挂了一个相当于 每个写入和读取都写入和读取了所有节点)
* n=5, w=r=3, 可以容忍2个节点挂掉

Sloppy Quorum - N个节点的副本 n个节点的副本是primary N-n是secondary w+r>n 但是当n中间有节点挂了 可以用N-n的节点在组成新的 n 来继续保证 w+r > n. 当原始 n 的节点回来之后, 恢复之前的配置。临时节点将所有的写入发送到恢复的主节点。此过程被称为handoff. Sloppy Quorum极大提高了可用性但是不能确保读到的某个key的value是most recently updated. 

When w+r>n, you still has chance to get stale value:
1. sloppy quorum - w个写入和r个读取可能落在不同的节点
2. 如果两个写入同事发生, 不清楚哪一个先发生, 安全的解决方案是合并并发写入(ref: 处理写入冲突). LLW 可能会由于写入时钟偏差而丢失.
3. 读写同时发生, 写可能仅仅反映在某些副本上. 这种情况下不确定返回的是stale value or new value
4. 