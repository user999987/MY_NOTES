## 弱隔离
### 读已提交 read committed 
最基本的 保证了没有 
* 脏读 一个事务还未提交 另一个事务看到了写入的数据 - 数据库保留一个对象的 一个提交版本
* 脏写 一个事务的写入尚未提交，后面的写入覆盖了第一个事务尚未提交的值 - row level lock

### 快照隔离
Alice 在银行有 1k 的储蓄, 分为两个账户, 每个 500, 现在从一个账户转100到另一个账户 如果在事务处理的过程中查看了账户余额 他很可能在一个账户中看到500 另一个账户中看到400
* 脏写 - row level lock
* 读偏差read skew - 数据库保留一个对象的不同提交版本 MVCC

索引怎么办？
* 指向对象所有版本，需要索引查询来过滤当前事务不可见的任何对象版本
* 仅追加的B树 每个写入事务都会创建一颗新的B树，当创建时，从该特定树根生长的树就是数据库的一个一致性快照。需要一个后台负责压缩和垃圾收集的进程。

### lost update
读取 修改 写入 两个这种模式的事务同时执行 其中一个的修改可能会丢失
1. 原子写
```
// 以下指令在大多数关系中是并发安全的
UPDATE counters SET value = value + 1 WHERE key = 'foo';
```
2. 显式锁定 - FOR UPDATE 子句告诉数据库应该对该查询返回的所有行加锁。忘记在代码某处加锁很容易引入竞争条件。
```
BEGIN TRANSACTION;
SELECT * FROM figures
  WHERE name = 'robot' AND game_id = 222
FOR UPDATE;

-- 检查玩家的操作是否有效，然后更新先前 SELECT 返回棋子的位置。
UPDATE figures SET position = 'c4' WHERE id = 1234;
COMMIT;
```
3. 事务管理器 自动检测丢失的更新
4. CAS compare and set
```sql
// 根据数据库的实现情况，这可能安全也可能不安全
UPDATE wiki_pages SET content = '新内容'
  WHERE id = 1234 AND content = '旧内容';
```

* 如果内容已经修改且不与 旧值 匹配 则更新不起作用 需要认为检查更新是否生效 必要时重试
* 如果数据库允许 where 子句从旧快照中读取 这个语句跟没有一样
5. 冲突解决和复制
    * 允许并发写入创建多个冲突版本的值，之后解决和合并这些版本
    * LWW最后写入胜利 会丢数据 但是也简单 是许多复制数据库的默认方案

### 写入偏差和幻读
写入偏差是一般化的丢失更新, 丢失更新是特殊化的写入偏差. 如果两个事务读取相同的对象:
* 修改同一个对象 丢失更新 或 脏写
* 修改不同对象（出现异常或者导致一些约束被破坏） 写入偏差

典型的例子是boss掉落装备的拾取

写偏差 需要真正的可串行化隔离 如果无法使用可串行化的隔离 次优选项可能是显式锁定事务锁依赖的
```
BEGIN TRANSACTION;
SELECT * FROM doctors
  WHERE on_call = TRUE
  AND shift_id = 1234 FOR UPDATE;

UPDATE doctors
  SET on_call = FALSE
  WHERE name = 'Alice'
  AND shift_id = 1234;
  
COMMIT;
```
一个事务中的写入改变另一个事务的搜索查询的结果，被称为 幻读。会导致棘手的写入偏差
* 不可重复读：在同一个事务中，由于其他事务的并发更新（UPDATE）操作，前后两次读取同一行数据时，数据发生了变化
* 幻读：在同一个事务中，由于其他事务的并发插入（INSERT）或删除（DELETE）操作，前后两次读取同一范围内的数据时，结果集发生了变化

## 可串行化
### 真正可串行化
在单个线程上按顺序一次只执行一个事务，应用程序提前将整个事务代码作为存储过程提交给数据库。顺序执行所有事务使并发控制简单多了，但数据库的事务吞吐量被限制为单机单核的速度。只读事务可以使用快照隔离在其它地方执行，但对于写入吞吐量较高的应用，单线程事务处理器可能成为一个严重的瓶颈。

分区可以使事务吞吐量与 CPU 核数保持线性伸缩。由于跨分区事务具有额外的协调开销，所以它们比单分区事务慢得多。

* 每个事务都必须小而快，只要有一个缓慢的事务，就会拖慢所有事务处理。
* 仅限于活跃数据集可以放入内存的情况。很少访问的数据可能会被移动到磁盘，但如果需要在单线程执行的事务中访问这些磁盘中的数据，系统就会变得非常慢 。
* 写入吞吐量必须低到能在单个 CPU 核上处理，如若不然，事务需要能划分至单个分区，且不需要跨分区协调。
* 跨分区事务是可能的，但是它们能被使用的程度有很大的限制。

### 2PL get and release
只要没有写入就允许多个事务同时读取同一个对象（共享锁）。但对象只要有写入（修改或删除），就需要 `独占访问`（exclusive access） 权限： 
* 如果事务 A 读取了一个对象，并且事务 B 想要写入该对象，那么 B 必须等到 A 提交或中止才能继续（事务 A 读取了一个对象并获得了共享锁，这时事务 B 想要写入该对象，必须等待事务 A 完成并释放共享锁。这确保了在事务 A 读取对象期间，其他事务不能对该对象进行写操作，从而保证了数据的一致性和避免了不可预测的结果。）
* 如果事务 A 写入了一个对象，并且事务 B 想要读取该对象，则 B 必须等到 A 提交或中止才能继续

#### 实现2PL
* 若事务要读取对象，则须先以共享模式获取锁。允许多个事务同时持有共享锁。但如果另一个事务已经在对象上持有排它锁，则这些事务必须等待。
* 若事务要写入一个对象，它必须首先以独占模式获取该锁。没有其他事务可以同时持有锁（无论是共享模式还是独占模式），所以如果对象上存在任何锁，该事务必须等待
* 如果事务先读取再写入对象，则它可能会将其共享锁升级为独占锁。升级锁的工作与直接获得独占锁相同。
* 事务获得锁之后，必须继续持有锁直到事务结束（提交或中止）。这就是 “两阶段” 这个名字的来源：第一阶段（当事务正在执行时）获取锁，第二阶段（在事务结束时）释放所有的锁

由于使用了这么多的锁，因此很可能会发生：事务 A 等待事务 B 释放它的锁，事务 B 等待事务 A 释放它的锁，这种情况叫做 死锁（Deadlock）。数据库会自动检测事务之间的死锁，并中止其中一个，以便另一个继续执行。被中止的事务需要由应用程序重试。
#### 2PL 性能
两阶段锁定的巨大缺点，以及 70 年代以来没有被所有人使用的原因，是其性能问题。两阶段锁定下的事务吞吐量与查询响应时间要比弱隔离级别下要差得多：
* 多个事务想要访问同一个对象，那么可能会形成一个队列
* 运行 2PL 的数据库可能具有相当不稳定的延迟。一个缓慢的事务，或者一个访问大量数据并获取许多锁的事务，就能把系统的其他部分拖慢，甚至迫使系统停机
* 如果死锁很频繁，这可能意味着巨大的浪费。

#### 谓词锁 predicate lock
谓词锁（predicate lock）。它类似于前面描述的共享 / 排它锁，但不属于特定的对象（例如，表中的一行），它属于所有符合某些搜索条件的对象
* 如果事务 A 想要读取匹配某些条件的对象，就像在这个 SELECT 查询中那样，它必须获取查询条件上的 共享谓词锁（shared-mode predicate lock）。如果另一个事务 B 持有任何满足这一查询条件对象的排它锁，那么 A 必须等到 B 释放它的锁之后才允许进行查询。
* 如果事务 A 想要插入，更新或删除任何对象，则必须首先检查旧值或新值是否与任何现有的谓词锁匹配。如果事务 B 持有匹配的谓词锁，那么 A 必须等到 B 已经提交或中止后才能继续。
#### 索引范围锁
谓词锁性能不佳：如果活跃事务持有很多锁，检查匹配的锁会非常耗时。大多数使用 2PL 的数据库实际上实现了索引范围锁（index-range locking，也称为 next-key locking），这是一个简化的近似版谓词锁。

在房间预订数据库中，你可能会在 room_id 列上有一个索引，并且 / 或者在 start_time 和 end_time 上有索引
* 你的索引位于 room_id 上，并且数据库使用此索引查找 123 号房间的现有预订。现在数据库可以简单地将共享锁附加到这个索引项上，指示事务已搜索 123 号房间用于预订。
* 基于时间的索引来查找现有预订，那么它可以将共享锁附加到该索引中的一系列值，指示事务已经将 12:00~13:00 时间段标记为用于预定。

无论哪种方式，搜索条件的近似值都附加到其中一个索引上。现在，如果另一个事务想要插入、更新或删除同一个房间和 / 或重叠时间段的预订，则它将不得不更新索引的相同部分。在这样做的过程中，它会遇到共享锁，它将被迫等到锁被释放。

索引范围锁并不像谓词锁那样精确（它们可能会锁定更大范围的对象，而不是维持可串行化所必需的范围），但是由于它们的开销较低，所以是一个很好的折衷。

如果没有可以挂载范围锁的索引，数据库可以退化到使用整个表上的共享锁。这对性能不利，因为它会阻止所有其他事务写入表格，但这是一个安全的回退位置。

### 可串行化快照隔离
2PL 是一种所谓的 悲观并发控制机制

串行化快照隔离 是一种 乐观（optimistic） 的并发控制技术。如果存在潜在的危险也不阻止事务，而是继续执行事务。当一个事务想要提交时，数据库检查是否有什么不好的事情发生（即隔离是否被违反）；如果是的话，事务将被中止，并且必须重试。只有可串行化的事务才被允许提交。

乐观控制是一个古老的想法。当争用（contention，很多事务试图访问相同的对象）表现不佳。

SSI 在在快照隔离的基础上，添加了一种算法来检测写入之间的串行化冲突，并确定要中止哪些事务。

快照隔离的写入偏差都遵循一个模式：
1. 事务从数据库读取数据
2. 根据看到的结果采取一些操作(写入数据)

在快照隔离的情况下，原始查询的结果在事务提交时可能不再是最新的:
* 读之前 有写入 未提交 检测对旧 MVCC 对象版本的读取
* 读之后 有写入 检测影响先前读取的写入 

#### MVCC检测
数据库需要跟踪一个事务由于 MVCC 可见性规则而忽略另一个事务的写入。当事务想要提交时，数据库检查是否有任何被忽略的写入现在已经被提交。如果是这样，事务必须中止。为什么不立即中止事务？可能是只读事务。通过避免不必要的中止，SSI 保留了快照隔离从一致快照中长时间读取的能力

长时间读取的能力是指在数据库事务执行期间，该事务能够持续读取来自同一个一致快照的数据，即使其他并发事务在该事务执行过程中也在修改数据库。这个特性是在 SSI（Serializable Snapshot Isolation）隔离级别下实现的

#### 检测影响之前读取的写入
使用类似 索引范围锁 的技术，除了 SSI 锁 （读锁-共享锁，写锁-独占锁）只有 SSI锁 会阻塞其他事务。当事务写入数据库时，它必须在索引中查找最近曾读取受影响数据的其他事务。这个过程类似于在受影响的键范围上获取写锁，但锁并不会阻塞事务直到其他读事务完成，而是像警戒线一样只是简单通知其他事务：你们读过的数据可能不是最新的啦。事务 43 通知事务 42 其先前读已过时，反之亦然。事务 42 首先提交并成功，尽管事务 43 的写影响了 42 ，但因为事务 43 尚未提交，所以写入尚未生效。然而当事务 43 想要提交时，来自事务 42 的冲突写入已经被提交，所以事务 43 必须中止。
#### 可串行化快照隔离性能
与两阶段锁定相比，可串行化快照隔离的最大优点是一个事务不需要阻塞等待另一个事务所持有的锁。就像在快照隔离下一样，写不会阻塞读，反之亦然