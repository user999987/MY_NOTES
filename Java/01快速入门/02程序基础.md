# 程序基础

```java
/**
 * 可以用来自动创建文档的注释
 */
public class Hello {
    public static void main(String[] args) {
        // 向屏幕输出文本:
        System.out.println("Hello, world!");
        /* 多行注释开始
        注释内容
        注释结束 */
    }
} // class定义结束
```

## 变量和数据类型

Java 有两种变量 - 基本类型和引用类型

```java
int n = 100;
int x = n;
```

当执行 int n =100; 时, jvm 会为 n 分配一个'存储单元', 填入 100
执行 int x = n; 时, jvm 会为新分配一个存储单元给变量 x 并写入和变量 n 一样的值

### 基本数据类型

* 整型:byte, short, int, long
* 浮点型: float, double
* 字符型: char
* 布尔型: boolean

基本数据类型占用字节数
```
       ┌───┐
byte   │   │
       └───┘
       ┌───┬───┐
short  │   │   │
       └───┴───┘
       ┌───┬───┬───┬───┐
int    │   │   │   │   │
       └───┴───┴───┴───┘
       ┌───┬───┬───┬───┬───┬───┬───┬───┐
long   │   │   │   │   │   │   │   │   │
       └───┴───┴───┴───┴───┴───┴───┴───┘
       ┌───┬───┬───┬───┐
float  │   │   │   │   │
       └───┴───┴───┴───┘
       ┌───┬───┬───┬───┬───┬───┬───┬───┐
double │   │   │   │   │   │   │   │   │
       └───┴───┴───┴───┴───┴───┴───┴───┘
       ┌───┬───┐
char   │   │   │
       └───┴───┘
```

最高位的 bit 表示符号为 0 为正数 1 为负数
0 1 1 1 1 1 1 1 最大正数 2<sup>6</sup>+2<sup>5</sup>+2<sup>4</sup>+2<sup>3</sup>+2<sup>2</sup>+2<sup>1</sup>+2<sup>0</sup> = 2<sup>7</sup>-1\
如果不考虑符号位, 8 个bit 2<sup>7</sup>+...+2<sup>0</sup> = 2<sup>8</sup>-1

int 和 float 它们内在的表示是不一样的。在float中，第一位用作符号位，第2-9位是以2为底的指数部分，剩余位用作小数部分.

char 是使用单引号 <span style="color:red">**'**</span> , 要和双引号 <span style="color:red">**"**</span> 的字符串类型区别开

### 引用类型
除了上述的基本类型的变量，剩下的都是引用类型。例如 String 字符串:
```java
String s = "hello"
```

### 常量
final 修饰符
```java
final double PI = 3.14; // PI是一个常量
PI = 300; // compile error!
```

### 作用域
Python 的代码块 是 模块 函数 和 类定义
Java 用 {} 大括号 来辨别 代码块

## 运算
### 整数运算
整数由于存在范围限制，如果计算结果超出了范围，就会产生溢出，而溢出不会出错，却会得到一个奇怪的结果
```java
public class Main {
    public static void main(String[] args) {
        int x = 2147483640;
        int y = 15;
        int sum = x + y;
        System.out.println(sum); // -2147483641
    }
}
// 移位运算
int n = 7
n++;
n--;
int a = n << 1; // 00000000 00000000 00000000 00001110 = 14
int b = n << 2; // 00000000 00000000 00000000 00011100 = 28
int d = n << 29; // 11100000 00000000 00000000 00000000 = -536870912, 左移29位时，由于最高位变成1，因此结果变成了负数。

int n = 7;       // 00000000 00000000 00000000 00000111 = 7
int a = n >> 1;  // 00000000 00000000 00000000 00000011 = 3
int b = n >> 2;  // 00000000 00000000 00000000 00000001 = 1
int c = n >> 3;  // 00000000 00000000 00000000 00000000 = 0

int n = -536870912; 
int c = n >> 28; // 11111111 11111111 11111111 11111110 = -2 对一个负数进行右移，最高位的1不动，结果仍然是一个负数
int c = n >>> 29; // 00000000 00000000 00000000 00000111 = 7 使用>>>，它的特点是符号位跟着动

// 位运算 &: and, |: or, ~: not, ^:nor (different number return 1)
n = 0 ^ 0; // 0
n = 0 ^ 1; // 1
n = 1 ^ 0; // 1
n = 1 ^ 1; // 0

// 类型转换
int i = 12345;
short s = (short) i; // 12345
//超出范围的强制转型会得到错误的结果，原因是转型时，int的两个高位字节直接被扔掉，仅保留了低位的两个字节：
int i1 = 1234567;
short s1 = (short) i1; // -10617
```
### 浮点数运算
浮点数0.1在计算机中就无法精确表示，因为十进制的0.1换算成二进制是一个无限循环小数, 只能存储一个0.1的近似值. 因为浮点数常常无法精确表示，因此，浮点数运算会产生误差.\
由于浮点数存在运算误差，所以比较两个浮点数是否相等常常会出现错误的结果。正确的比较方法是判断两个浮点数之差的绝对值是否小于一个很小的数：

```java
// 比较x和y是否相等，先计算其差的绝对值:
double r = Math.abs(x - y);
// 再判断绝对值是否足够小:
if (r < 0.00001) {
    // 可以认为相等
} else {
    // 不相等
}
```

尽量保证运算时候数据类型相同 避免出现以下错误

```java
double d = 1.2 + 24 / 5; // 5.2
//计算结果为5.2，原因是编译器计算24 / 5这个子表达式时，按两个整数进行运算，结果仍为整数4。

// 除数为 0
double d1 = 0.0 / 0; // NaN
double d2 = 1.0 / 0; // Infinity
double d3 = -1.0 / 0; // -Infinity

// 浮点数 转 整数: 浮点数的小数部分会被丢掉。如果转型后超过了整型能表示的最大范围，将返回整型的最大值
int n1 = (int) 12.3; // 12
int n2 = (int) 12.7; // 12
int n2 = (int) -12.7; // -12
int n3 = (int) (12.7 + 0.5); // 13
int n4 = (int) 1.2e20; // 2147483647
// 如果要进行四舍五入，可以对浮点数加上0.5再强制转型
```

### 三元运算符

```java
b ? x : y
```

### 字符和字符串

```java
/* 因为Java在内存中总是使用Unicode表示字符，所以，一个英文字符和一个中文字符都用一个char类型表示，它们都占用两个字节。要显示一个字符的Unicode编码，只需将char类型直接赋值给int类型即可：*/
int n1 = 'A'; // 字母“A”的Unicodde编码是65
int n2 = '中'; // 汉字“中”的Unicode编码是20013

String s = "first line \n"
         + "second line \n"
         + "end";
```


### 数组类型

```java
int[] ns = new int[5];
ns[0] = 68;
ns[1] = 79;
ns[2] = 91;
ns[3] = 85;
ns[4] = 62;

int[] ns = new int[] { 68, 79, 91, 85, 62 };
// 还可以进一步简写为：
int[] ns = { 68, 79, 91, 85, 62 };
// 注意数组是引用类型，并且数组大小不可变。我们观察下面的代码：
ns = new int[] { 68, 79, 91, 85, 62 };
ns = new int[] { 1, 2, 3 };
// 当执行 ns = new int[] { 1, 2, 3 } ns 指向了一个新的 3个元素的数组

// 如果数组元素不是基本类型，而是一个引用类型，例如 字符串 类型。
String[] names = {
    "ABC", "XYZ", "zoo"
};
names[1] = "cat";
// names[1]指向的字符串"XYZ"并没有改变，仅仅是将names[1]的引用从指向"XYZ"改成了指向"cat"，其结果是字符串"XYZ"再也无法通过names[1]访问到了。

          ┌─────────────────────────┐
    names │   ┌─────────────────────┼───────────┐
      │   │   │                     │           │
      ▼   │   │                     ▼           ▼
┌───┬───┬─┴─┬─┴─┬───┬───────┬───┬───────┬───┬───────┬───┐
│   │░░░│░░░│░░░│   │ "ABC" │   │ "XYZ" │   │ "zoo" │   │
└───┴─┬─┴───┴───┴───┴───────┴───┴───────┴───┴───────┴───┘
      │                 ▲
      └─────────────────┘


          ┌─────────────────────────────────────────────────┐
    names │   ┌─────────────────────────────────┐           │
      │   │   │                                 │           │
      ▼   │   │                                 ▼           ▼
┌───┬───┬─┴─┬─┴─┬───┬───────┬───┬───────┬───┬───────┬───┬───────┬───┐
│   │░░░│░░░│░░░│   │ "ABC" │   │ "XYZ" │   │ "zoo" │   │ "cat" │   │
└───┴─┬─┴───┴───┴───┴───────┴───┴───────┴───┴───────┴───┴───────┴───┘
      │                 ▲
      └─────────────────┘
```